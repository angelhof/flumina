/*
    Timely code for the generators (data producers)
    in the Pageview example.
*/

use super::common::{Duration, Scope, Stream};
use super::generators::fixed_rate_source;
use super::pageview_data::{PVData, PVItem, PageData, PageName};
use super::util::rand_range;

/*
    Update source where page names and data are generated by a given closure.
*/
fn update_source_template<F1, F2, G>(
    mut name_gen: F1,
    mut data_gen: F2,
    frequency: Duration,
    exp_duration: Duration,
    scope: &G,
) -> Stream<G, PVItem>
where
    F1: FnMut() -> PageName + 'static,
    F2: FnMut() -> PageData + 'static,
    G: Scope<Timestamp = u128>,
{
    let item_gen = move |_time| {
        let page_name = name_gen();
        let page_data = data_gen();
        PVItem { data: PVData::Update(page_data), name: page_name }
    };
    fixed_rate_source(item_gen, scope, frequency, exp_duration)
}

/*
    View source where page names are generated by a given closure.
*/
fn view_source_template<F1, G>(
    mut name_gen: F1,
    frequency: Duration,
    exp_duration: Duration,
    scope: &G,
) -> Stream<G, PVItem>
where
    F1: FnMut() -> PageName + 'static,
    G: Scope<Timestamp = u128>,
{
    let item_gen = move |_time| {
        let page_name = name_gen();
        PVItem { data: PVData::View, name: page_name }
    };
    fixed_rate_source(item_gen, scope, frequency, exp_duration)
}

/*
    Function that is used to determine the page name from the worker index.
    For this experiment, input streams are assumed to partitioned this way
    at the source level.
*/
pub fn page_partition_function(
    num_pages: usize,
    worker_index: usize,
) -> PageName {
    (worker_index % num_pages) as PageName
}

/*
    Source for update events where:
    - the page name depends on the worker index
    - the page data is random between 0 and 100
*/
pub fn partitioned_update_source<G>(
    num_pages: usize,
    frequency: Duration,
    exp_duration: Duration,
    scope: &G,
    worker_index: usize,
) -> Stream<G, PVItem>
where
    G: Scope<Timestamp = u128>,
{
    update_source_template(
        move || page_partition_function(num_pages, worker_index),
        || rand_range(0, 100),
        frequency,
        exp_duration,
        scope,
    )
}

/*
    Source for view events where:
    - the page name depends on the worker index
*/
pub fn partitioned_view_source<G>(
    num_pages: usize,
    frequency: Duration,
    exp_duration: Duration,
    scope: &G,
    worker_index: usize,
) -> Stream<G, PVItem>
where
    G: Scope<Timestamp = u128>,
{
    view_source_template(
        move || page_partition_function(num_pages, worker_index),
        frequency,
        exp_duration,
        scope,
    )
}

** Work TODO


*** DONE BUG: Heatbeats releases all messages, not caring about the messages that they depend on

At the moment, after every heartbeat, every message that has all its dependent timers higher than it,
is released. However that is not correct, because there might be a message that they depend on,
that depends on more tags, that was received before, but hasn't been released. This leads to inconsistencies.

FIX: 
Implement the clear buffer to only clear all the messages sequentially until it finds one which cannot
be cleared. This is a naive way to solve this bug, as this way messages might have to wait in the buffer
fo messages that they do not depend on to be released. Ideally an implementation would only release a message
if there is no message that it depends on previously in the buffer.

*** TODO Improve the clear_buffer function

After the above bug fix, messages wait in the buffer for every message that has a smaller timestamp
to be released first. However, this can lead to a situation where messages wait in the buffer despite
being independent than anything else before them. 

An improvement (that is still naive however as it traverses the buffer every time it needs to clear) is
to sequentially traverse the buffer, and keep the first timestamp of each tag that we see. This way
we we only release messages that don't have a dependent tag that has arrived earlier than them but hasn't
been released.

*** TODO Implement a taxi example where {id,1} is dependent to itself but not to {id,2}
    - [X] Define the computation
    - [X] Implement a producer that create {x,y} line coordinates for each taxi
    - [X] Define a sequential configuration
    - [ ] Define a distributed configuration

This could be messages with the position of the taxi, that arrive every second, and we want
to get the distance that the taxi has covered in every hour. So we need to compute the distance
between every two *consecutive* points and add them together.

*** TODO Handle a merge message as both a heartbeat and a normal message
    - [ ] Add the merge message to the buffer, and then clear the buffer using it as a heartbeat
    - [ ] Make sure that the dependencies of the merge message are handled correctly

Solution:
First add the merge to the buffer, and then clear the buffer (using the merge as a heartbeat).

The way it is done now, a merge messafe clears the buffer, but is then sent immediately to the node,
which could lead to a bug. Example: An "a" mailbox hasn't received an a heartbeat but it receives a 
"b" merge request. This will lead to the merge request being forwarded to the node, before the "a"s
that should have been already processed.

Problem:
In order to implement this solution, I have to make sure that the merge message will be handled correctly,
and cleared at the next a-heartbeat (or even immediately). Because of this, I might need to revise the 
clear dependencies functions that I call befoee initializing the mailbox to not delete the keys that
are not in a node's predicate.

*** TODO Optimize the add message to buffer to not wait for the next heartbeat

At the moment, a message is added to the buffer without even thinking whether it might need to be released
or not. Think of a way to optimize this so that a new message is not necessarily added to the buffer, 
but could rather be sent to the node (before or after other messages that might also need to be sent)

*** TODO Optimize the buffer to not hold a sorted list of all messages 

This degrades performance as some messages might not need to be ordered in the buffer. This way
we sort everything no matter whether they do need to be ordered or not.

*** DONE Improve the mailbox to only forward heartbeats to nodes for which it satisfies their pred

In order for this to work, higher nodes should just ask the lower ones with their merges when they need.
In order for that to happen, we need to read (or be able to compute) the alpha mapping from the beta mapping
that we currently have as a predicate. It is important that the predicates are set up correctly in the beginning.

In essence, a parent node, loses messages that satisfy its descendant predicates, 
and so it shouldn't receive heartbeats for those messages, as it will learn from them
when asking for a merge.

*** TODO Allow dependencies to be based on predicates rather than tags

At the moment there is a mismatch between tags and predicates and I need to decide on which of
both to use. If we decide to use predicates we need to think about the dependencies and how should
they be encoded in the system.

*** DONE Implement an optimization that allows for part of the state to be left behind in a merge

This can be implemented as an or-split, that has an empty predicate where the part of the state is left
behind.

*** TODO Implement an optimization that allows for merges to happen in any order

All independent merges should be mergable in any order, (associativity, commutativity).
If we only allow them to happen in the order they were split, this might deteriorate performance.

*** TODO Implement testing infastructure to test if the results of example executions 
*** TODO Maybe we need an and-merge

It seems like there should be an and-merge to be paired with the and_split because it
seems that usually an or-merge could/shpould be different than the and-merge. 

*** TODO Implement infastructure for producers.   

Their input should be a list of messages. 
The following should be configurable:
- The rate at which they send messages
- The density of heartbeats that they will interleave in the data
- Whether or not to reorder data that are independent

*** TODO Implement a compiler

That given the topology and the specification of the computation,
distributes the computation accordingly (as we have done now in the 
distributed() function in the abexample)

*** DONE Implement a message tracing mechanism

It should trace all the messages that are exchanged, and the function calls that are made.
Then by using this information together with the topology of the network and a mapping
of the process ids to nodes, we could estimate statistics on the execution of the program.

*** TODO Implement infastructure that allows for a separate msg and split predicate

At the moment the message predicate of a node is the same as its split predicate

*** DONE (Make sure that the implementation makes sense) Implement the alpha and beta mappings

The alpha mapping used to be what messages must a node receive in order to be able to process
the messages in its beta mapping.

However, it seems like thsi can be derived from the dependencies and the beta mapping (which currenty is
a boolean predicate on messages). 

The alphia mapping of a node, is the dependencies that it waits on, and the process to derive it
is described in node:remove_unnecassary_dependencies/3. In short, a node doesn't need to wait
for the messages that are processed by its descendants because it will learn for them when it asks
for a merge, as only the leaf nodes do processing without merging.

*** TODO Improve the simplicity of implementing something in our framework

Test how easy it is implement complicated queries in our intermediate language.
Try to push its expresiveness.

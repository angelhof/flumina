** Work TODO

*** DONE Improve the mailbox to only forward heartbeats to nodes for which it satisfies their pred

In order for this to work, higher nodes should just ask the lower ones with their merges when they need.
In order for that to happen, we need to read (or be able to compute) the alpha mapping from the beta mapping
that we currently have as a predicate. It is important that the predicates are set up correctly in the beginning.

In essence, a parent node, loses messages that satisfy its descendant predicates, 
and so it shouldn't receive heartbeats for those messages, as it will learn from them
when asking for a merge.

*** TODO Allow dependencies to be based on predicates rather than tags

At the moment there is a mismatch between tags and predicates and I need to decide on which of
both to use. If we decide to use predicates we need to think about the dependencies and how should
they be encoded in the system.

*** TODO Implement an optimization that allows for part of the state to be left behind in a merge

Some ideas are written in a TODO note in the taxiexample.erl

*** TODO Implement an optimization that allows for merges to happen in any order

All independent merges should be mergable in any order, (associativity, commutativity).
If we only allow them to happen in the order they were split, this might deteriorate performance.

*** TODO Implement testing infastructure to test if the results of example executions 
*** TODO Maybe we need an and-merge

It seems like there should be an and-merge to be paired with the and_split because it
seems that usually an or-merge could/shpould be different than the and-merge. 

*** TODO Implement infastructure for producers.   

Their input should be a list of messages. 
The following should be configurable:
- The rate at which they send messages
- The density of heartbeats that they will interleave in the data
- Whether or not to reorder data that are independent

*** TODO Implement a compiler

That given the topology and the specification of the computation,
distributes the computation accordingly (as we have done now in the 
distributed() function in the abexample)

*** TODO Implement a tracing mechanism

It should trace all the messages that are exchanged, and the function calls that are made.
Then by using this information together with the topology of the network and a mapping
of the process ids to nodes, we could estimate statistics on the execution of the program.

*** TODO Implement infastructure that allows for a separate msg and split predicate

At the moment the message predicate of a node is the same as its split predicate

*** DONE (Make sure that the implementation makes sense) Implement the alpha and beta mappings

The alpha mapping used to be what messages must a node receive in order to be able to process
the messages in its beta mapping.

However, it seems like thsi can be derived from the dependencies and the beta mapping (which currenty is
a boolean predicate on messages). 

The alphia mapping of a node, is the dependencies that it waits on, and the process to derive it
is described in node:remove_unnecassary_dependencies/3. In short, a node doesn't need to wait
for the messages that are processed by its descendants because it will learn for them when it asks
for a merge, as only the leaf nodes do processing without merging.

*** TODO Improve the simplicity of implementing something in our framework

Test how easy it is implement complicated queries in our intermediate language.
Try to push its expresiveness.
